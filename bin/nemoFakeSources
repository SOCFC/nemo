#!/usr/bin/env python
#
# makes maps and catalogs containing fake sources only, for selection function type stuff

import sys
import os
import datetime
from nemo import *
from nemo import gnfw
import nemo
import pylab
import pickle
import nemoCython
import numpy
import pyfits
import time
from astLib import *
from scipy import ndimage
from scipy import interpolate
import atpy
numpy.random.seed()
pylab.matplotlib.interactive(True)

#from IPython.Shell import IPShellEmbed
#ipshell = IPShellEmbed([], banner = 'Dropping into IPython', exit_msg = 'Leaving Interpreter, back to program.')

#-------------------------------------------------------------------------------------------------------------
def insertBetaModel(mapData, wcs, thresholdMap, footprintMap, segMap, modelParams):
    """Inserts a beta model into the map. The beta model can be elliptical. Adds source properties to the 
    object.
    
    Returns updated map data with source inserted, and an objDict corresponding to the object inserted.

    """
    
    # Try to keep clusters somewhat separated from objects already in map
    halfBorderPix=100
    
    t0=time.time()
    inMap=False
    while inMap == False:
        x=numpy.random.uniform(mapData.shape[1])
        y=numpy.random.uniform(mapData.shape[0])
        yMin=int(y)-halfBorderPix
        yMax=int(y)+halfBorderPix
        xMin=int(x)-halfBorderPix
        xMax=int(x)+halfBorderPix
        if yMin < 0:
            yMin=0
        if xMin < 0:
            xMin=0
        if yMax > mapData.shape[0]-1:
            yMax=mapData.shape[0]-1
        if xMax > mapData.shape[1]-1:
            xMax=mapData.shape[1]-1
        if thresholdMap[int(y), int(x)] == True and numpy.sum(segMap[yMin:yMax, xMin:xMax]) == 0:
            RADeg, decDeg=wcs.pix2wcs(x, y)
            inMap=True
    
    beta=modelParams['beta'][numpy.random.randint(len(modelParams['beta']))]
    deltaT0=modelParams['deltaT0'][numpy.random.randint(len(modelParams['deltaT0']))]
    coreRadiusArcmin=modelParams['coreRadiusArcmin'][numpy.random.randint(len(modelParams['coreRadiusArcmin']))]
    axisRatio=modelParams['axisRatio'][numpy.random.randint(len(modelParams['axisRatio']))]

    # 2d beta model from Halverson et al. 2009 
    # Old way
    #phi=numpy.random.uniform(-numpy.pi, numpy.pi)
    #xDegMap, yDegMap=nemoCython.makeXYDegreesDistanceMaps(mapData, wcs, RADeg, 
                                                          #decDeg, (20*coreRadiusArcmin)/60.0)
    #A=numpy.power((numpy.cos(phi)*xDegMap+numpy.sin(phi)*yDegMap), 2)/numpy.power(coreRadiusArcmin/60.0, 2)
    #B=numpy.power((-numpy.sin(phi)*xDegMap+numpy.cos(phi)*yDegMap), 2)/numpy.power((axisRatio*coreRadiusArcmin)/60.0, 2)
    #objMap=deltaT0*numpy.power(1+A+B, (1-3*beta)/2)

    # Faster - but still 4 sec per source
    phi=numpy.random.uniform(-numpy.pi, numpy.pi)
    xDegMap, yDegMap=nemoCython.makeXYDegreesDistanceMaps(mapData, wcs, RADeg, 
                                                          decDeg, (20*coreRadiusArcmin)/60.0)
    mask=numpy.less(xDegMap, 1000)
    A=numpy.power((numpy.cos(phi)*xDegMap[mask]+numpy.sin(phi)*yDegMap[mask]), 2)/numpy.power(coreRadiusArcmin/60.0, 2)
    B=numpy.power((-numpy.sin(phi)*xDegMap[mask]+numpy.cos(phi)*yDegMap[mask]), 2)/numpy.power((axisRatio*coreRadiusArcmin)/60.0, 2)
    objMap=numpy.zeros(mapData.shape)
    objMap[mask]=deltaT0*numpy.power(1+A+B, (1-3*beta)/2)
    
    # Trim off edge stuff
    objMap[numpy.greater(xDegMap, 1000)]=0.0
    objMap=objMap*footprintMap
    
    # Keep track of where splatted stuff down in segMap, to avoid overlaps
    segMap[numpy.not_equal(objMap, 0)]=1.0
    
    # Object properties
    objDict={}
    objDict['name']='fake_'+catalogTools.makeACTName(RADeg, decDeg)
    objDict['RADeg']=RADeg
    objDict['decDeg']=decDeg
    objDict['deltaT0']=deltaT0
    objDict['beta']=beta
    objDict['coreRadiusArcmin']=coreRadiusArcmin
    objDict['phi']=phi
    
    # An integrated Y inside various apertures - hmm, these are circular, how useful is this?
    rDegMap=nemoCython.makeDegreesDistanceMap(mapData, wcs, RADeg, decDeg, (20*coreRadiusArcmin)/60.0)
    aperturesArcmin=[0.5, 1.0, 2.0, 3.0, 4.0]
    for apArcmin in aperturesArcmin:
        mask=numpy.less(rDegMap, apArcmin/60.0)    
        sumPix=mapTools.convertToY(objMap[mask], obsFrequencyGHz = 148.0).sum()
        ra0=objDict['RADeg']
        dec0=objDict['decDeg']
        x0, y0=wcs.wcs2pix(ra0, dec0)
        ra1, dec1=wcs.pix2wcs(x0+1, y0+1)    
        xLocalDegPerPix=astCoords.calcAngSepDeg(ra0, dec0, ra1, dec0)
        yLocalDegPerPix=astCoords.calcAngSepDeg(ra0, dec0, ra0, dec1)
        arcmin2PerPix=xLocalDegPerPix*yLocalDegPerPix*60.0**2
        YArcmin2=sumPix*arcmin2PerPix
        objDict['YArcmin2_%.1fArcminRadius' % (apArcmin)]=YArcmin2
    
    #t1=time.time()
    #print "... time taken to insert source = %.3f sec ..." % (t1-t0)
    
    return [mapData+objMap, objDict, segMap]

#-------------------------------------------------------------------------------------------------------------
def insertArnaudModel(mapData, wcs, thresholdMap, footprintMap, segMap, modelParams):
    """Insert Arnaud et al. (2010) GNFW model into the map. 
    
    Returns updated map data with source inserted, and an objDict corresponding to the object inserted.
    
    """
            
    # Try to keep clusters somewhat separated from objects already in map
    halfBorderPix=100
    
    t0=time.time()
    inMap=False
    while inMap == False:
        x=numpy.random.uniform(mapData.shape[1])
        y=numpy.random.uniform(mapData.shape[0])
        yMin=int(y)-halfBorderPix
        yMax=int(y)+halfBorderPix
        xMin=int(x)-halfBorderPix
        xMax=int(x)+halfBorderPix
        if yMin < 0:
            yMin=0
        if xMin < 0:
            xMin=0
        if yMax > mapData.shape[0]-1:
            yMax=mapData.shape[0]-1
        if xMax > mapData.shape[1]-1:
            xMax=mapData.shape[1]-1
        if thresholdMap[int(y), int(x)] == True and numpy.sum(segMap[yMin:yMax, xMin:xMax]) == 0:
            RADeg, decDeg=wcs.pix2wcs(x, y)
            inMap=True
    
    # The profile shape, defined such that b500 = 1 and b is equivalent to projected x (I think)...
    # Except for Arnaud, x = r/r500 but for Matthew x = c500*(r/r500)
    # This means that c500 acts as a stretch such that b500 = 1/c500 (I think)
    # We have to do some interpolation here as we can't just feed e.g. bMap through gnfw.integrated
    bRange=numpy.linspace(0, 30, 1000)
    cylPProfile=[]
    for b in bRange:
        cylPProfile.append(gnfw.integrated(b))
    cylPProfile=numpy.array(cylPProfile)
    
    # Normalise to 1 at centre
    cylPProfile=cylPProfile/cylPProfile.max()
    
    # Map between b and angular coordinates for random model
    # All shape parameters apart from c500 are fixed in gnfw.py to Arnaud et al. values
    c500=modelParams['c500'][numpy.random.randint(len(modelParams['c500']))]
    deltaT0=modelParams['deltaT0'][numpy.random.randint(len(modelParams['deltaT0']))]
    theta500Arcmin=modelParams['theta500Arcmin'][numpy.random.randint(len(modelParams['theta500Arcmin']))]
    thetaDegRange=(bRange*(theta500Arcmin/60.0))/c500
    tckP=interpolate.splrep(thetaDegRange, cylPProfile)
    
    # Insert into map
    rDegMap=nemoCython.makeDegreesDistanceMap(mapData, wcs, RADeg, decDeg, (20*theta500Arcmin)/60.0)
    mask=numpy.less(rDegMap, 1000)
    objMap=numpy.zeros(mapData.shape)
    objMap[mask]=deltaT0*interpolate.splev(rDegMap[mask], tckP)
    
    # Trim off edge stuff
    objMap[numpy.greater(rDegMap, 100)]=0.0
    objMap=objMap*footprintMap
    
    # Keep track of where splatted stuff down in segMap, to avoid overlaps
    segMap[numpy.not_equal(objMap, 0)]=1.0
    
    # Object properties
    objDict={}
    objDict['name']='fake_'+catalogTools.makeACTName(RADeg, decDeg)
    objDict['RADeg']=RADeg
    objDict['decDeg']=decDeg
    objDict['deltaT0']=deltaT0
    objDict['c500']=c500
    objDict['theta500Arcmin']=theta500Arcmin
    
    # An integrated Y inside various apertures measured directly from map
    #aperturesArcmin=[0.5, 1.0, 2.0, 3.0, 4.0]
    #old=[]
    #for apArcmin in aperturesArcmin:
        #objDict['YArcmin2_%.1fArcminRadius' % (apArcmin)]=calcYFromMap(apArcmin, objMap, objDict, rDegMap, wcs)
        #old.append(objDict['YArcmin2_%.1fArcminRadius' % (apArcmin)])
    #objDict['YArcmin2_theta500Radius']=calcYFromMap(theta500Arcmin, objMap, objDict, rDegMap, wcs)
    
    # Or... calculated by integrating the profile
    aperturesArcmin=[0.5, 1.0, 2.0, 3.0, 4.0]
    for apArcmin in aperturesArcmin:
        objDict['YArcmin2_%.1fArcminRadius' % (apArcmin)]=calcYDirectly(apArcmin, deltaT0, cylPProfile, thetaDegRange)
    objDict['YArcmin2_theta500Radius']=calcYDirectly(theta500Arcmin, deltaT0, cylPProfile, thetaDegRange)    
    objDict['YArcmin2_5theta500Radius']=calcYDirectly(5*theta500Arcmin, deltaT0, cylPProfile, thetaDegRange)    

    t1=time.time()
    print "... time taken to insert source = %.3f sec ..." % (t1-t0)
    
    return [mapData+objMap, objDict, segMap]

#-------------------------------------------------------------------------------------------------------------
def insertPhysicalArnaudModel(mapData, wcs, thresholdMap, footprintMap, segMap, modelParams):
    """Insert Arnaud et al. (2010) GNFW model into the map. This version assumes a cosmology and Y-mass
    relation.
    
    Returns updated map data with source inserted, and an objDict corresponding to the object inserted.
    
    """
    
    # We have to assume a cosmology and a Y-mass scaling relation
    #astCalc.OMEGA_M0=modelParams['Omega_M0']
    #astCalc.OMEGA_L=modelParams['Omega_Lambda']
    #astCalc.OMEGA_H0=modelParams['H0']

    # Try to keep clusters somewhat separated from objects already in map
    halfBorderPix=100
    
    t0=time.time()
    inMap=False
    timeout=10.0    # give up if the map seems to be full already and we don't want to overlap clusters
    while inMap == False:
        x=numpy.random.uniform(mapData.shape[1])
        y=numpy.random.uniform(mapData.shape[0])
        yMin=int(y)-halfBorderPix
        yMax=int(y)+halfBorderPix
        xMin=int(x)-halfBorderPix
        xMax=int(x)+halfBorderPix
        if yMin < 0:
            yMin=0
        if xMin < 0:
            xMin=0
        if yMax > mapData.shape[0]-1:
            yMax=mapData.shape[0]-1
        if xMax > mapData.shape[1]-1:
            xMax=mapData.shape[1]-1
        t1=time.time()
        if (t0-t1) > timeout:
            return "Timed out"
        if thresholdMap[int(y), int(x)] == True and numpy.sum(segMap[yMin:yMax, xMin:xMax]) == 0:
            RADeg, decDeg=wcs.pix2wcs(x, y)
            inMap=True
    
    # The profile shape, defined such that b500 = 1 and b is equivalent to projected x (I think)...
    # Except for Arnaud, x = r/r500 but for Matthew x = c500*(r/r500)
    # This means that c500 acts as a stretch such that b500 = 1/c500 (I think)
    # We have to do some interpolation here as we can't just feed e.g. bMap through gnfw.integrated
    bRange=numpy.linspace(0, 30, 1000)
    cylPProfile=[]
    for b in bRange:
        cylPProfile.append(gnfw.integrated(b))
    cylPProfile=numpy.array(cylPProfile)
    
    # Normalise to 1 at centre
    cylPProfile=cylPProfile/cylPProfile.max()

    # Calculate R500Mpc, theta500Arcmin corresponding to random mass and redshift
    z=modelParams['redshift'][numpy.random.randint(len(modelParams['redshift']))]
    M500=numpy.power(10, modelParams['logM500'][numpy.random.randint(len(modelParams['logM500']))])
    Ez=astCalc.Ez(z)    # h(z) in Arnaud speak
    Hz=astCalc.Ez(z)*astCalc.H0  
    G=4.301e-9  # in MSun-1 km2 s-2 Mpc, see Robotham GAMA groups paper
    criticalDensity=(3*numpy.power(Hz, 2))/(8*numpy.pi*G)
    R500Mpc=numpy.power((3*M500)/(4*numpy.pi*500*criticalDensity), 1.0/3.0)
    theta500Arcmin=numpy.degrees(numpy.arctan(R500Mpc/astCalc.da(z)))*60.0

    # Map between b and angular coordinates for random model
    c500=modelParams['c500'][numpy.random.randint(len(modelParams['c500']))]    
    thetaDegRange=(bRange*(theta500Arcmin/60.0))/c500
    tckP=interpolate.splrep(thetaDegRange, cylPProfile)
    
    # Now we need to adopt a scaling between Y500 (cylindrical for us) and mass
    # Let's go with Arnaud et al. Section 6.3 (eq. 25), where R500 is used as the aperture
    # Their cosmology is Omega_m0=0.3, Omega_Lambda=0.7, H0=70 km/s/Mpc
    alpha=1.78
    logBx=-4.665
    constantsTimesYSZ=numpy.power(10, logBx)*numpy.power(M500/3e14, alpha)
    YSZ_R500_sr=constantsTimesYSZ/(numpy.power(Ez, -2.0/3.0)*numpy.power(astCalc.da(z), 2))   # in steradians
    srToArcmin2=numpy.power(numpy.radians(1.0/60.0), 2)
    YSZ_R500_arcmin2=YSZ_R500_sr/srToArcmin2
    
    # The above is the number we want, now normalise the profile to get that inside R500 and what deltaT0
    # is
    fidDeltaT0=-500.0
    yProfile=mapTools.convertToY(fidDeltaT0*cylPProfile)
    tcky=interpolate.splrep(thetaDegRange, yProfile)
    fineDegRange=numpy.linspace(0, theta500Arcmin/60.0, 1000)
    fineyProfile=interpolate.splev(fineDegRange, tcky)    
    YArcmin2=numpy.trapz(fineyProfile*numpy.pi*2*fineDegRange*60, fineDegRange*60)
    norm=YSZ_R500_arcmin2/YArcmin2
    deltaT0=fidDeltaT0*norm
    
    # Insert into map
    rDegMap=nemoCython.makeDegreesDistanceMap(mapData, wcs, RADeg, decDeg, (20*theta500Arcmin)/60.0)
    mask=numpy.less(rDegMap, 1000)
    objMap=numpy.zeros(mapData.shape)
    objMap[mask]=deltaT0*interpolate.splev(rDegMap[mask], tckP)
    
    # Trim off edge stuff
    objMap[numpy.greater(rDegMap, 100)]=0.0
    objMap=objMap*footprintMap
    
    # Keep track of where splatted stuff down in segMap, to avoid overlaps
    segMap[numpy.not_equal(objMap, 0)]=1.0
    
    # Object properties
    objDict={}
    objDict['name']='fake_'+catalogTools.makeACTName(RADeg, decDeg)
    objDict['RADeg']=RADeg
    objDict['decDeg']=decDeg
    objDict['deltaT0']=deltaT0
    objDict['c500']=c500
    objDict['theta500Arcmin']=theta500Arcmin
    objDict['R500Mpc']=R500Mpc
    objDict['M500']=M500
    objDict['z']=z
    
    # An integrated Y inside various apertures measured directly from map - this is just a sanity check
    #aperturesArcmin=[0.5, 1.0, 2.0, 3.0, 4.0]
    #for apArcmin in aperturesArcmin:
        #objDict['YArcmin2_%.1fArcminRadius_fromMap' % (apArcmin)]=calcYFromMap(apArcmin, objMap, objDict, rDegMap, wcs)
    
    # Or... calculated by integrating the profile
    aperturesArcmin=[0.5, 1.0, 2.0, 3.0, 4.0]
    for apArcmin in aperturesArcmin:
        objDict['YArcmin2_%.1fArcminRadius' % (apArcmin)]=calcYDirectly(apArcmin, deltaT0, cylPProfile, thetaDegRange)
    objDict['YArcmin2_theta500Radius']=calcYDirectly(theta500Arcmin, deltaT0, cylPProfile, thetaDegRange)    
    objDict['YArcmin2_5theta500Radius']=calcYDirectly(5*theta500Arcmin, deltaT0, cylPProfile, thetaDegRange)    
    
    t1=time.time()
    print "... time taken to insert source = %.3f sec ..." % (t1-t0)
    
    return [mapData+objMap, objDict, segMap]
    
#-------------------------------------------------------------------------------------------------------------
def calcYFromMap(apArcmin, objMap, objDict, rDegMap, wcs):
    """Calculate integrated Y within aperture from the map at the given object position.
    
    """
    
    mask=numpy.less(rDegMap, apArcmin/60.0)    
    sumPix=mapTools.convertToY(objMap[mask], obsFrequencyGHz = 148.0).sum()
    ra0=objDict['RADeg']
    dec0=objDict['decDeg']
    x0, y0=wcs.wcs2pix(ra0, dec0)
    ra1, dec1=wcs.pix2wcs(x0+1, y0+1)    
    xLocalDegPerPix=astCoords.calcAngSepDeg(ra0, dec0, ra1, dec0)
    yLocalDegPerPix=astCoords.calcAngSepDeg(ra0, dec0, ra0, dec1)
    arcmin2PerPix=xLocalDegPerPix*yLocalDegPerPix*60.0**2
    YArcmin2=sumPix*arcmin2PerPix

    return YArcmin2

#-------------------------------------------------------------------------------------------------------------
def calcYDirectly(apRadiusArcmin, deltaT0, cylPProfile, thetaDegRange):
    """Calculate integrated Y within aperture by directly integrating the 1d profile.
    
    """
    
    # Integrate over a circle
    yProfile=mapTools.convertToY(deltaT0*cylPProfile)
    tcky=interpolate.splrep(thetaDegRange, yProfile)
    fineDegRange=numpy.linspace(0, apRadiusArcmin/60.0, 1000)
    fineyProfile=interpolate.splev(fineDegRange, tcky)    
    YArcmin2=numpy.trapz(fineyProfile*numpy.pi*2*fineDegRange*60, fineDegRange*60)

    return YArcmin2
    
#-------------------------------------------------------------------------------------------------------------
# Main
if len(sys.argv) < 2:
    print "Run: % nemoFakeSources < .par file(s)>"
else:
    
    parDictFileName=sys.argv[1]
        
    print ">>> Running .par file: %s" % (parDictFileName)
    parDict=actDict.ACTDict()
    parDict.read_from_file(parDictFileName)

    # Output dirs
    if 'outputDir' in parDict.keys():
        rootOutDir=parDict['outDir']
    else:
        if parDictFileName.find(".par") == -1:
            raise Exception, "File must have .par extension"
        rootOutDir=sys.argv[1].replace(".par", "")
    dirList=[rootOutDir]
    for d in dirList:
        if os.path.exists(d) == False:
            os.makedirs(d)
                            
    # Set up map, footprint etc.
    img=pyfits.open(parDict['weightsFileName'])
    wht=img[0].data
    wcs=astWCS.WCS(img[0].header, mode = 'pyfits')
    thresholdMap=numpy.array(numpy.greater(wht, parDict['minWeightThreshold']))
    footprintMap=numpy.array(numpy.greater(wht, 0))
    
    numRuns=parDict['numRuns']
    sourcesPerRun=parDict['sourcesPerRun']
    fakeSourceType=parDict['fakeSourceType']
    fakeSourceParams=parDict['fakeSourceParams']
    beamFWHMArcmin=parDict['beamFWHMArcmin']
    if fakeSourceType == 'betaModel':
        insertSource=insertBetaModel
    elif fakeSourceType == 'arnaudModel':
        insertSource=insertArnaudModel
    elif fakeSourceType == 'physicalArnaudModel':
        insertSource=insertPhysicalArnaudModel
    else:
        raise Exception, "didn't understand fakeSourceType"
    
    for run in range(numRuns):
        
        print ">>> Run: %d" % (run)
        outDir=rootOutDir
        if os.path.exists(outDir+os.path.sep+"148Map_%s_run%d.fits" % (fakeSourceType, run)) == False:
            
            # Insert sources...
            mapData=numpy.zeros(wht.shape)
            segMap=numpy.zeros(mapData.shape)
            catalog=[]
            for i in range(sourcesPerRun):
                print "... inserted source %d/%d ..." % (i+1, sourcesPerRun)
                stuff=insertSource(mapData, wcs, thresholdMap, footprintMap, segMap, fakeSourceParams)
                if stuff == "Timed out":
                    break
                else:
                    mapData, objDict, segMap=stuff
                catalog.append(objDict)
        
            # Check comparison of Y measured from map with Y calculated from integrating the profile
            #new=[]
            #old=[]
            #for obj in catalog:
                #new.append(obj['YArcmin2_4.0ArcminRadius'])
                #old.append(obj['YArcmin2_4.0ArcminRadius_fromMap'])                
            #pylab.plot(old, new, 'r.')
            #pylab.xlabel("Y$_{\sf Map}$ (arcmin$^2$)") 
            #pylab.ylabel("Y$_{\sf Direct}$ (arcmin$^2$)")
            #pylab.plot(numpy.linspace(0, 1, 3), numpy.linspace(0, 1, 3), 'k--')
            #pylab.xlim(0, 0.01)
            #pylab.ylim(0, 0.01)
            
            # Make a test scaling relation plot
            #srToArcmin2=numpy.power(numpy.radians(1.0/60.0), 2)
            #plotYSZ=[]
            #plotMass=[]
            #for obj in catalog:
                #plotMass.append(obj['M500'])
                #Ez=astCalc.Ez(obj['z'])    # h(z) in Arnaud speak
                #constantsTimesYSZ=numpy.power(Ez, -2.0/3.0)*numpy.power(astCalc.da(obj['z']), 2)*(obj['YArcmin2_5theta500Radius']*srToArcmin2)
                #plotYSZ.append(constantsTimesYSZ)
            #pylab.plot(plotMass, plotYSZ, 'r.')
            #pylab.plot(plotMass, plotYSZ, 'b-')
            #pylab.loglog()
            #pylab.ylabel("E(z)$^{-2/3}$ Y$_{\sf SZ(5R_{500})}$ (Mpc$^{-2}$)")
            #pylab.xlabel("M$_{500}$ (M$_\odot$)")
            #ipshell()
            #sys.exit()
            
            # Convert catalog to ATPy table, write as FITS
            tabFileName=outDir+os.path.sep+"%s_run%d_catalog.fits" % (fakeSourceType, run)
            if os.path.exists(tabFileName) == True:
                os.remove(tabFileName)
            tab=atpy.Table()
            for key in catalog[0].keys():
                arr=[]
                for obj in catalog:
                    arr.append(obj[key])
                tab.add_column(key, numpy.array(arr))
            tab.write(tabFileName)

            # Write handy DS9 .reg file
            catalogTools.catalog2DS9(catalog, outDir+os.path.sep+"%s_run%d_catalog.reg" % (fakeSourceType, run), 
                                    addInfo = [{'key': 'deltaT0', 'fmt': '%.1f'}])
                            
            # Write out beam convolved or not maps
            astImages.saveFITS(outDir+os.path.sep+"148Map_%s_run%d.fits" % (fakeSourceType, run), mapData, wcs)
            
            # This is wrong, wrong, wrong
            #beamSigma=beamFWHMArcmin/numpy.sqrt(8.0*numpy.log(2.0))            
            #beamSigmaPix=(beamSigma/60.0)/wcs.getYPixelSizeDeg()
            #mapData=ndimage.gaussian_filter1d(mapData, beamSigmaPix)
            #astImages.saveFITS(outDir+os.path.sep+"148Map_%s_run%d_beamConvolved.fits" % (fakeSourceType, run), mapData, wcs)
            ##astImages.saveFITS(outDir+os.path.sep+"segMap_run%d.fits" % (run), segMap, wcs)
        else:
            print "... already done - skipping ..."

    # Make archive
    os.system("cp %s %s/" % (parDictFileName, outDir))
    tgzFileName=outDir+".tar.gz"
    if os.path.exists(tgzFileName) == True:
        os.system("rm %s " % (tgzFileName))
    os.system("tar -zcvf %s %s" % (tgzFileName, outDir))

            
    
                            
     
        

    
    