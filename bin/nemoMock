#!/usr/bin/env python

"""

Generate mock cluster catalogs - runs on output from nemo, nemoMass, nemoSelFn

"""

import os
import sys
import resource
import glob
import numpy as np
import pylab as plt
import astropy.table as atpy
from astLib import *
from scipy import stats
from scipy import interpolate
from scipy import ndimage
from scipy import optimize
from nemo import signals
from nemo import maps
from nemo import catalogs
from nemo import MockSurvey
from nemo import selFnTools
from nemo import plotSettings
from nemo import startUp
import argparse
import types
import pickle
import astropy.io.fits as pyfits
import time
import yaml
import IPython
plt.matplotlib.interactive(False)

#------------------------------------------------------------------------------------------------------------
if __name__ == '__main__':

    parser=argparse.ArgumentParser("nemoMock")
    parser.add_argument("configFileName", help="""A .yml configuration file.""")
    parser.add_argument("-M", "--mpi", dest="MPIEnabled", action="store_true", help="""Enable MPI. If you
                        want to use this, run using something like: mpiexec --np 4 nemoMock ...""", 
                        default = False)
    args = parser.parse_args()
    
    parDictFileName=args.configFileName
    config=startUp.NemoConfig(parDictFileName, MPIEnabled = args.MPIEnabled)

    if 'makeMockCatalogs' in config.parDict.keys():
        numMocksToMake=config.parDict['makeMockCatalogs']
    else:
        numMocksToMake=1

    # Noise sources in mocks
    if 'applyPoissonScatter' in config.parDict.keys():
        applyPoissonScatter=config.parDict['applyPoissonScatter']
    else:
        applyPoissonScatter=True
    if 'applyIntrinsicScatter' in config.parDict.keys():
        applyIntrinsicScatter=config.parDict['applyIntrinsicScatter']
    else:
        applyIntrinsicScatter=True
    if 'applyNoiseScatter' in config.parDict.keys():
        applyNoiseScatter=config.parDict['applyNoiseScatter']
    else:
        applyNoiseScatter=True
    print(">>> Mock noise sources (Poisson, intrinsic, measurement noise) = (%s, %s, %s) ..." % (applyPoissonScatter, applyIntrinsicScatter, applyNoiseScatter))

    # Remove this once we re-jig for MPI
    if config.MPIEnabled == True and numMocksToMake > 1:
        raise Exception("nemoMock needs to be adapted for MPI if making multiple mocks - not done yet")
    
    # Q varies across tiles
    tckQFitDict=signals.fitQ(config)

    # We only care about the filter used for fixed_ columns
    photFilterLabel=config.parDict['photometryOptions']['photFilter']
    for filterDict in config.parDict['mapFilters']:
        if filterDict['label'] == photFilterLabel:
            break

    # The same as was used for detecting objects
    thresholdSigma=config.parDict['thresholdSigma']

    # We need an assumed scaling relation for mock observations
    scalingRelationDict=config.parDict['massOptions']
    
    # Set-up MockSurvey objects to be used to generate multiple mocks here
    # The reason for doing this is that enableDrawSample = True makes this very slow for 3000 mass bins...
    print(">>> Setting up mock surveys dictionary ...")
    t0=time.time()
    mockSurveyDict={}
    wcsDict={}
    RMSMapDict={}
    for extName in config.extNames:
        # Need area covered 
        areaImg=pyfits.open(config.diagnosticsDir+os.path.sep+"areaMask#%s.fits" % (extName))
        areaMask=areaImg[0].data
        wcs=astWCS.WCS(areaImg[0].header, mode = 'pyfits')
        areaDeg2=(areaMask*maps.getPixelAreaArcmin2Map(areaMask, wcs)).sum()/(60**2)

        # Need RMS map to apply selection function
        RMSImg=pyfits.open(config.diagnosticsDir+os.path.sep+"RMSMap_%s#%s.fits" % (photFilterLabel, extName))
        RMSMap=RMSImg[0].data
    
        # For a mock, we could vary the input cosmology...
        minMass=5e13
        zMin=0.0
        zMax=2.0
        H0=70.
        Om0=0.30
        Ob0=0.05
        sigma_8=0.8
        mockSurvey=MockSurvey.MockSurvey(minMass, areaDeg2, zMin, zMax, H0, Om0, Ob0, sigma_8, enableDrawSample = True)
        
        mockSurveyDict[extName]=mockSurvey
        RMSMapDict[extName]=RMSMap
        wcsDict[extName]=wcs
    
    t1=time.time()
    print("... took %.3f sec ..." % (t1-t0))
    
    print(">>> Making mock catalogs ...")
    for i in range(numMocksToMake):       
        mockTabsList=[]
        for extName in config.extNames:
            t0=time.time()
            mockTab=mockSurveyDict[extName].drawSample(RMSMapDict[extName], scalingRelationDict, tckQFitDict, wcs = wcsDict[extName], 
                                                       photFilterLabel = photFilterLabel, extName = extName, makeNames = True,
                                                       SNRLimit = thresholdSigma, applySNRCut = True, 
                                                       applyPoissonScatter = applyPoissonScatter, 
                                                       applyIntrinsicScatter = applyIntrinsicScatter,
                                                       applyNoiseScatter = applyNoiseScatter)
            t1=time.time()
            mockTabsList.append(mockTab)
            print("... making mock catalog %d for extName = %s took %.3f sec ..." % (i+1, extName, t1-t0))
            
        tab=atpy.vstack(mockTabsList)
                
        # Write catalog and .reg file
        colNames=['name', 'RADeg', 'decDeg', 'template', 'redshift', 'redshiftErr', 'true_M500', 'true_fixed_y_c', 'fixed_SNR', 'fixed_y_c', 'fixed_err_y_c']
        colFmts =['%s',   '%.6f',  '%.6f',   '%s',       '%.3f',     '%.3f',        '%.3f',      '%.3f',           '%.1f',      '%.3f',      '%.3f']
        mockCatalogFileName=config.mocksDir+os.path.sep+"mockCatalog_%d.csv" % (i+1)
        catalogs.writeCatalogFromTab(tab, mockCatalogFileName, colNames, colFmts, 
                                         constraintsList = [], headings = True)

        addInfo=[{'key': 'fixed_SNR', 'fmt': '%.1f'}]
        catalogs.catalog2DS9(tab, mockCatalogFileName.replace(".csv", ".reg"), constraintsList = [], 
                                addInfo = addInfo, color = "cyan") 
        
    if 'combineMocks' in config.parDict.keys() and config.parDict['combineMocks'] == True:
        tab=None
        for i in range(numMocksToMake):
            mockCatalogFileName=config.mocksDir+os.path.sep+"mockCatalog_%d.fits" % (i+1)
            stackTab=atpy.Table().read(mockCatalogFileName)
            if tab == None:
                tab=stackTab
            else:
                tab=atpy.vstack([tab, stackTab])
        outFileName=config.mocksDir+os.path.sep+"mockCatalog_combined.fits"
        if os.path.exists(outFileName) == True:
            os.remove(outFileName)
        tab.write(outFileName)
    
    # Write a small text file with the parameters used to generate the mocks into the mocks dir (easier than using headers)
    mockKeys=['massOptions', 'makeMockCatalogs', 'applyPoissonScatter', 'applyIntrinsicScatter', 'applyNoiseScatter']
    with open(config.mocksDir+os.path.sep+"mockParameters.txt", "w") as outFile:
        for m in mockKeys:
            if m in config.parDict.keys():
                outFile.write("%s: %s\n" % (m, config.parDict[m]))
