#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""

Calculate mass completeness limits, assuming the RMS map(s) are correct

"""

import os
import sys
import resource
import glob
import numpy as np
import pylab as plt
import astropy.table as atpy
from astLib import *
from scipy import stats
from scipy import interpolate
from scipy import ndimage
from scipy import optimize
from nemo import actDict
from nemo import simsTools
from nemo import mapTools
from nemo import MockSurvey
from nemo import selFnTools
#from nemo import SelFn
#from nemo import photometry
from nemo import plotSettings
import types
import pickle
import astropy.io.fits as pyfits
import time
import IPython
plt.matplotlib.interactive(False)

# If want to catch warnings as errors...
#import warnings
#warnings.filterwarnings('error')
    
#------------------------------------------------------------------------------------------------------------
# Main
if len(sys.argv) < 2:
    print "Run: % nemoSelFn < .par file(s)>"
else:
    
    parDictFileNames=sys.argv[1:]
    
    for parDictFileName in parDictFileNames:
    
        # This first part is all the same as the main nemo script
        print ">>> Running .par file: %s" % (parDictFileName)
        parDict=actDict.ACTDict()
        parDict.read_from_file(parDictFileName)

        MPIEnabled=parDict['useMPI']
        if MPIEnabled ==True:
            from mpi4py import MPI
            comm=MPI.COMM_WORLD
            size=comm.Get_size()
            rank=comm.Get_rank()
            if size == 1:
                raise Exception, "if you want to use MPI, run with e.g., mpirun --np 4 nemoSelFn ..."
        else:
            rank=0

        # Output dirs
        if 'outputDir' in parDict.keys():
            rootOutDir=parDict['outDir']
        else:
            if parDictFileName.find(".par") == -1:
                raise Exception, "File must have .par extension"
            rootOutDir=sys.argv[1].replace(".par", "")
        filteredMapsDir=rootOutDir+os.path.sep+"filteredMaps"
        diagnosticsDir=rootOutDir+os.path.sep+"diagnostics"
        dirList=[rootOutDir, filteredMapsDir]
        if rank == 0:
            for d in dirList:
                if os.path.exists(d) == False:
                    os.makedirs(d)
                    
        # Optional override of default GNFW parameters (used by Arnaud model), if used in filters given
        if 'GNFWParams' not in parDict.keys():
            parDict['GNFWParams']='default'
        for filtDict in parDict['mapFilters']:
            filtDict['params']['GNFWParams']=parDict['GNFWParams']

        # tileDeck file handling - either make one, or handle loading of one
        # MPI: if the tileDeck doesn't exist, only one process makes it - the others wait until it is done
        if rank == 0:
            unfilteredMapsDictList, extNames=mapTools.makeTileDeck(parDict)
            madeTileDeck=True
        else:
            madeTileDeck=None
        if MPIEnabled == True:
            madeTileDeck=comm.bcast(madeTileDeck, root = 0)
            if rank != 0 and madeTileDeck == True:
                unfilteredMapsDictList, extNames=mapTools.makeTileDeck(parDict)
            
        # For when we want to test on only a subset of tiles
        if 'extNameList' in parDict.keys():
            newList=[]
            for name in extNames:
                if name in parDict['extNameList']:
                    newList.append(name)
            if newList == []:
                raise Exception, "extNameList given in .par file but no extensions in images match"
            extNames=newList
        
        # MPI: just divide up tiles pointed at by extNames among processes
        if MPIEnabled == True:
            numTilesPerNode=len(extNames)/size
            startIndex=numTilesPerNode*rank
            if rank == size-1:
                endIndex=len(extNames)
            else:
                endIndex=numTilesPerNode*(rank+1)
        else:
            startIndex=0
            endIndex=len(extNames)
        extNames=extNames[startIndex:endIndex]
        # For debugging...
        print("... rank = %d: extNames = %s" % (rank, str(extNames)))

        # Now we get into selection function stuff...
        # Q varies across tiles
        tckQFitDict=simsTools.fitQ(parDict, diagnosticsDir, filteredMapsDir)

        # Since a fiducial cosmology (OmegaM0 = 0.3, OmegaL0 = 0.7, H0 = 70 km/s/Mpc) was used in the object detection/filtering stage, we use the same one here      
        minMass=5e13
        areaDeg2=400.0  # Don't care what value this has, as we'll sim up an arbitrary number of clusters anyway
        zMin=0.0
        zMax=2.0
        H0=70.
        Om0=0.30
        Ob0=0.05
        sigma_8=0.8
        mockSurvey=MockSurvey.MockSurvey(minMass, areaDeg2, zMin, zMax, H0, Om0, Ob0, sigma_8, enableDrawSample = True)
        
        # We only care about the filter used for fixed_ columns
        photFilterLabel=parDict['photometryOptions']['photFilter']
        for filterDict in parDict['mapFilters']:
            if filterDict['label'] == photFilterLabel:
                break

        # We'll only calculate completeness for this given selection
        SNRCut=parDict['selFnOptions']['fixed_SNR_cut']

        # Run the selection function calculation on each tile in turn
        selFnDictList=[]
        for extName in extNames:
            tileAreaDeg2=selFnTools.getTileTotalAreaDeg2(extName, diagnosticsDir)
            y0Noise=selFnTools.calcTileWeightedAverageNoise(extName, photFilterLabel, diagnosticsDir)
            fitTab=selFnTools.calcCompleteness(y0Noise, SNRCut, extName, mockSurvey, parDict['massOptions'], tckQFitDict, diagnosticsDir,
                                               fitTabFileName = diagnosticsDir+os.path.sep+"selFn_fitTab#%s.fits" % (extName))
            # We will eventually want to use interpolation of fitTab results to make 2d completeness array on mockSurvey grid, as used in HSC stuff
            selFnDict={'extName': extName,
                       'y0Noise': y0Noise,
                       'tileAreaDeg2': tileAreaDeg2,
                       'fitTab': fitTab}
            selFnDictList.append(selFnDict)

            # Optional mass-limit maps
            if 'massLimitMaps' in parDict['selFnOptions'].keys():
                for massLimitDict in parDict['selFnOptions']['massLimitMaps']:
                    selFnTools.makeMassLimitMap(SNRCut, massLimitDict['z'], extName, photFilterLabel, mockSurvey, 
                                                parDict['massOptions'], tckQFitDict, diagnosticsDir)  
            
        # MPI: gather together selection function results, so we can compute survey-wide average
        if MPIEnabled == True:
            gathered_selFnDictLists=comm.gather(selFnDictList, root = 0)
            if rank != 0:
                assert gathered_selFnDictLists is None
                print "... MPI rank %d finished ..." % (rank)
                sys.exit()
            else:
                print "... gathering selection function results ..."
                all_selFnDictList=[]
                for dictList in gathered_selFnDictLists:
                    all_selFnDictList=all_selFnDictList+dictList
        else:
            all_selFnDictList=selFnDictList
                
        # Survey-averaged 90% mass completeness limit
        tileAreas=[]
        completeness=[]
        for selFnDict in all_selFnDictList:
            tileAreas.append(selFnDict['tileAreaDeg2'])
            completeness.append(np.array(selFnDict['fitTab']['log10MLimit_90%']))
        tileAreas=np.array(tileAreas)
        fracArea=tileAreas/np.sum(tileAreas)
        completeness=np.array(completeness)
        zRange=np.array(selFnDict['fitTab']['z'])
        massLimit_90Complete=np.average(np.power(10, completeness)/1e14, axis = 0, weights = fracArea)  # agrees with full mass limit map
        selFnTools.makeMassLimitVRedshiftPlot(massLimit_90Complete, zRange, diagnosticsDir+os.path.sep+"completeness90Percent_surveyAverage.pdf")
        averageMassLimit_90Complete=massLimit_90Complete[np.logical_and(np.greater(zRange, 0.2), np.less(zRange, 1.0))].mean()        
        print(">>> Survey-averaged results:")
        print("... total survey area (after masking) = %.3f sq deg ..." % (np.sum(tileAreas)))
        print("... survey-averaged 90%% mass completeness limit (z = 0.5) = %.3f x 10^14 MSun" % (massLimit_90Complete[np.where(zRange == 0.5)][0]))
        print("... survey-averaged 90%% mass completeness limit (0.2 < z < 1.0) = %.3f x 10^14 MSun" % (averageMassLimit_90Complete))

        # If we made mass limit maps...
        # ... make cumulative area versus mass limit plot(s)
        # ... and downsampled full area (untiled) map(s) and plot(s) of the mass limit
        if 'massLimitMaps' in parDict['selFnOptions'].keys():
            for massLimitDict in parDict['selFnOptions']['massLimitMaps']:
                selFnTools.cumulativeAreaMassLimitPlot(massLimitDict['z'], diagnosticsDir) 
                selFnTools.makeFullSurveyMassLimitMapPlot(massLimitDict['z'], diagnosticsDir)
            
            
