#!/usr/bin/env python

"""

Calculate mass completeness limits, assuming the RMS map(s) are correct

"""

import os
import sys
import resource
import glob
import numpy as np
import pylab as plt
import astropy.table as atpy
from astLib import *
from scipy import stats
from scipy import interpolate
from scipy import ndimage
from scipy import optimize
from nemo import simsTools
from nemo import mapTools
from nemo import MockSurvey
from nemo import selFnTools
from nemo import plotSettings
from nemo import startUp
import types
import pickle
import astropy.io.fits as pyfits
import time
import yaml
import IPython
plt.matplotlib.interactive(False)

# If want to catch warnings as errors...
#import warnings
#warnings.filterwarnings('error')
    
#------------------------------------------------------------------------------------------------------------
# Main
if len(sys.argv) < 2:
    print("Run: % nemoSelFn <.yml config file>")
else:
    
    parDictFileName=sys.argv[1]
    parDict, rootOutDir, filteredMapsDir, diagnosticsDir, unfilteredMapsDictList, extNames, comm, rank, size=startUp.startUp(parDictFileName)
    
    # Now we get into selection function stuff...
    # Q varies across tiles
    tckQFitDict=simsTools.fitQ(parDict, diagnosticsDir, filteredMapsDir)

    # Since a fiducial cosmology (OmegaM0 = 0.3, OmegaL0 = 0.7, H0 = 70 km/s/Mpc) was used in the object detection/filtering stage, we use the same one here      
    minMass=5e13
    areaDeg2=400.0  # Don't care what value this has, as we'll sim up an arbitrary number of clusters anyway
    zMin=0.0
    zMax=2.0
    H0=70.
    Om0=0.30
    Ob0=0.05
    sigma_8=0.8
    mockSurvey=MockSurvey.MockSurvey(minMass, areaDeg2, zMin, zMax, H0, Om0, Ob0, sigma_8, enableDrawSample = True)
    
    # We only care about the filter used for fixed_ columns
    photFilterLabel=parDict['photometryOptions']['photFilter']
    for filterDict in parDict['mapFilters']:
        if filterDict['label'] == photFilterLabel:
            break

    # We'll only calculate completeness for this given selection
    SNRCut=parDict['selFnOptions']['fixedSNRCut']

    # Run the selection function calculation on each tile in turn (by default, we only calculate tile/survey averages)
    selFnDictList=[]
    for extName in extNames:
        
        tileAreaDeg2=selFnTools.getTileTotalAreaDeg2(extName, diagnosticsDir)
        y0Noise=selFnTools.calcTileWeightedAverageNoise(extName, photFilterLabel, diagnosticsDir)
        fitTab=selFnTools.calcCompleteness(y0Noise, SNRCut, extName, mockSurvey, parDict['massOptions'], tckQFitDict, diagnosticsDir,
                                           fitTabFileName = diagnosticsDir+os.path.sep+"selFn_fitTab#%s.fits" % (extName))
        selFnDict={'extName': extName,
                   'y0Noise': y0Noise,
                   'tileAreaDeg2': tileAreaDeg2,
                   'fitTab': fitTab}
        selFnDictList.append(selFnDict)
        
        # Optional mass-limit maps
        if 'massLimitMaps' in list(parDict['selFnOptions'].keys()):
            for massLimitDict in parDict['selFnOptions']['massLimitMaps']:
                selFnTools.makeMassLimitMap(SNRCut, massLimitDict['z'], extName, photFilterLabel, mockSurvey, 
                                            parDict['massOptions'], tckQFitDict, diagnosticsDir)  
        
    # MPI: gather together selection function results, so we can compute survey-wide average
    if parDict['useMPI'] == True:
        gathered_selFnDictLists=comm.gather(selFnDictList, root = 0)
        if rank != 0:
            assert gathered_selFnDictLists is None
            print("... MPI rank %d finished ..." % (rank))
            sys.exit()
        else:
            print("... gathering selection function results ...")
            all_selFnDictList=[]
            for dictList in gathered_selFnDictLists:
                all_selFnDictList=all_selFnDictList+dictList
    else:
        all_selFnDictList=selFnDictList
            
    # Survey-averaged 90% mass completeness limit
    tileAreas=[]
    completeness=[]
    for selFnDict in all_selFnDictList:
        tileAreas.append(selFnDict['tileAreaDeg2'])
        completeness.append(np.array(selFnDict['fitTab']['log10MLimit_90%']))
    tileAreas=np.array(tileAreas)
    fracArea=tileAreas/np.sum(tileAreas)
    completeness=np.array(completeness)
    zRange=np.array(selFnDict['fitTab']['z'])
    massLimit_90Complete=np.average(np.power(10, completeness)/1e14, axis = 0, weights = fracArea)  # agrees with full mass limit map
    selFnTools.makeMassLimitVRedshiftPlot(massLimit_90Complete, zRange, diagnosticsDir+os.path.sep+"completeness90Percent_surveyAverage.pdf")
    
    print(">>> Survey-averaged results:")
    averageMassLimit_90Complete=massLimit_90Complete[np.logical_and(np.greater(zRange, 0.2), np.less(zRange, 1.0))].mean()
    print(("... total survey area (after masking) = %.3f sq deg ..." % (np.sum(tileAreas))))
    print(("... survey-averaged 90%% mass completeness limit (z = 0.5) = %.3f x 10^14 MSun" % (massLimit_90Complete[np.where(zRange == 0.5)][0])))
    print(("... survey-averaged 90%% mass completeness limit (0.2 < z < 1.0) = %.3f x 10^14 MSun" % (averageMassLimit_90Complete)))

    # Make survey-averaged (M, z) grid(s) as used by e.g. HSC lensing analysis
    # For surveys like KiDS, HSC etc.. we calculate area of intersection for each footprint with each tile (extName), and weight accordingly
    footprintsList=[{'label': 'surveyAverage', 'maskList': []}]
    if 'selFnFootprints' in parDict.keys():
        footprintsList=footprintsList+parDict['selFnFootprints']
    for footprintDict in footprintsList:
        print(">>> Creating (M, z) completeness grid for %s footprint ..." % (footprintDict['label']))
        selFnTools.saveMzCompletenessGrid(footprintDict['label'], all_selFnDictList, mockSurvey, diagnosticsDir, 
                                          extraMasksList = footprintDict['maskList'])

    # If we made mass limit maps...
    # ... make cumulative area versus mass limit plot(s)
    # ... and downsampled full area (untiled) map(s) and plot(s) of the mass limit
    if 'massLimitMaps' in parDict['selFnOptions'].keys():
        print(">>> Making cumulative area plots and full survey mass limit plots ...")
        for massLimitDict in parDict['selFnOptions']['massLimitMaps']:
            selFnTools.cumulativeAreaMassLimitPlot(massLimitDict['z'], diagnosticsDir) 
            selFnTools.makeFullSurveyMassLimitMapPlot(massLimitDict['z'], diagnosticsDir)
            
            
