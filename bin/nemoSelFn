#!/usr/bin/env python

"""

Calculate mass completeness limits, assuming the RMS map(s) are correct

"""

import os
import sys
import resource
import glob
import numpy as np
import pylab as plt
import astropy.table as atpy
from astLib import *
from scipy import stats
from scipy import interpolate
from scipy import ndimage
from scipy import optimize
from nemo import simsTools
from nemo import mapTools
from nemo import MockSurvey
from nemo import selFnTools
from nemo import plotSettings
from nemo import startUp
import argparse
import types
import pickle
import astropy.io.fits as pyfits
import time
import yaml
import IPython
plt.matplotlib.interactive(False)

# If want to catch warnings as errors...
#import warnings
#warnings.filterwarnings('error')
    
#------------------------------------------------------------------------------------------------------------
if __name__ == '__main__':

    parser=argparse.ArgumentParser("nemoSelFn")
    parser.add_argument("configFileName", help="""A .yml configuration file.""")
    parser.add_argument("-M", "--mpi", dest="MPIEnabled", action="store_true", help="""Enable MPI. If you
                        want to use this, run using something like: mpiexec --np 4 nemoSelFn ...""", 
                        default = False)
    args = parser.parse_args()
    
    parDictFileName=args.configFileName
    parDict, rootOutDir, filteredMapsDir, diagnosticsDir, unfilteredMapsDictList, extNames, comm, rank, size=startUp.startUp(parDictFileName)
    parDict['MPIEnabled']=args.MPIEnabled

    # Q varies across tiles
    tckQFitDict=simsTools.fitQ(parDict, diagnosticsDir, filteredMapsDir)

    # Since a fiducial cosmology (OmegaM0 = 0.3, OmegaL0 = 0.7, H0 = 70 km/s/Mpc) was used in the object detection/filtering stage, we use the same one here      
    minMass=8e13
    areaDeg2=400.0  # Don't care what value this has, as we'll sim up an arbitrary number of clusters anyway
    zMin=0.0
    zMax=2.0
    H0=70.
    Om0=0.30
    Ob0=0.05
    sigma_8=0.8
    mockSurvey=MockSurvey.MockSurvey(minMass, areaDeg2, zMin, zMax, H0, Om0, Ob0, sigma_8, enableDrawSample = True)
    
    # We only care about the filter used for fixed_ columns
    photFilterLabel=parDict['photometryOptions']['photFilter']
    for filterDict in parDict['mapFilters']:
        if filterDict['label'] == photFilterLabel:
            break

    # We'll only calculate completeness for this given selection
    SNRCut=parDict['selFnOptions']['fixedSNRCut']

    # Handle any missing options for calcCompleteness (these aren't used by the default fast method anyway)
    if 'numDraws' not in parDict['selFnOptions'].keys():
        parDict['selFnOptions']['numDraws']=2000000
    if 'numIterations' not in parDict['selFnOptions'].keys():
        parDict['selFnOptions']['numIterations']=100
    
    # We can calculate stats in different extra areas (e.g., inside optical survey footprints)
    footprintsList=[]
    if 'selFnFootprints' in parDict.keys():
        footprintsList=footprintsList+parDict['selFnFootprints']
        
    # Run the selection function calculation on each tile in turn
    selFnCollection={'full': []}
    for footprintDict in footprintsList:
        if footprintDict['label'] not in selFnCollection.keys():
            selFnCollection[footprintDict['label']]=[]
            
    for extName in extNames:
        
        tileAreaDeg2=selFnTools.getTileTotalAreaDeg2(extName, diagnosticsDir)
        #y0Noise=selFnTools.calcTileWeightedAverageNoise(extName, photFilterLabel, diagnosticsDir)
        RMSTab=selFnTools.getRMSTab(extName, photFilterLabel, diagnosticsDir)
        compMz=selFnTools.calcCompleteness(RMSTab, SNRCut, extName, mockSurvey, parDict['massOptions'], tckQFitDict, 
                                           numDraws = parDict['selFnOptions']['numDraws'],
                                           numIterations = parDict['selFnOptions']['numIterations'],
                                           method = parDict['selFnOptions']['method'],
                                           plotFileName = diagnosticsDir+os.path.sep+"completeness90Percent#%s.pdf" % (extName))
        selFnDict={'extName': extName,
                   'RMSTab': RMSTab,
                   'tileAreaDeg2': tileAreaDeg2,
                   'compMz': compMz}
        selFnCollection['full'].append(selFnDict)
        
        # Generate footprint intersection masks (e.g., with HSC) and RMS tables, which are cached
        # May as well do this bit here (in parallel) and assemble output later
        for footprintDict in footprintsList:
            selFnTools.makeIntersectionMask(extName, diagnosticsDir, footprintDict['label'], masksList = footprintDict['maskList'])
            tileAreaDeg2=selFnTools.getTileTotalAreaDeg2(extName, diagnosticsDir, footprintLabel = footprintDict['label'])
            if tileAreaDeg2 > 0:
                #y0Noise=selFnTools.calcTileWeightedAverageNoise(extName, photFilterLabel, diagnosticsDir, footprintLabel = footprintDict['label'])
                RMSTab=selFnTools.getRMSTab(extName, photFilterLabel, diagnosticsDir, footprintLabel = footprintDict['label'])
                compMz=selFnTools.calcCompleteness(RMSTab, SNRCut, extName, mockSurvey, parDict['massOptions'], tckQFitDict,
                                                   numDraws = parDict['selFnOptions']['numDraws'],
                                                   numIterations = parDict['selFnOptions']['numIterations'],
                                                   method = parDict['selFnOptions']['method'])
                selFnDict={'extName': extName,
                           'RMSTab': RMSTab,
                           'tileAreaDeg2': tileAreaDeg2,
                           'compMz': compMz}
                selFnCollection[footprintDict['label']].append(selFnDict)
        
        # Optional mass-limit maps
        if 'massLimitMaps' in list(parDict['selFnOptions'].keys()):
            for massLimitDict in parDict['selFnOptions']['massLimitMaps']:
                selFnTools.makeMassLimitMap(SNRCut, massLimitDict['z'], extName, photFilterLabel, mockSurvey, 
                                            parDict['massOptions'], tckQFitDict, diagnosticsDir)  
        
    # MPI: gather together selection function results, so we can compute survey-wide average
    if parDict['useMPI'] == True:
        gathered_selFnCollections=comm.gather(selFnCollection, root = 0)
        if rank != 0:
            assert gathered_selFnCollections is None
            print("... MPI rank %d finished ..." % (rank))
            sys.exit()
        else:
            print("... gathering selection function results ...")
            all_selFnCollection={'full': []}
            for key in selFnCollection.keys():
                if key not in all_selFnCollection.keys():
                    all_selFnCollection[key]=[]
            for selFnCollection in gathered_selFnCollections:
                for key in all_selFnCollection.keys():
                    all_selFnCollection[key]=all_selFnCollection[key]+selFnCollection[key]
            selFnCollection=all_selFnCollection
                
    # Survey completeness stats now all lumped together in one routine
    # This also make survey-averaged (M, z) grid(s) as used by e.g. HSC lensing analysis
    selFnTools.completenessByFootprint(selFnCollection, mockSurvey, diagnosticsDir, 
                                       additionalLabel = "_"+parDict['selFnOptions']['method'].replace(" ", "_"))
    
    # If we made mass limit maps...
    # ... make cumulative area versus mass limit plot(s)
    # ... and downsampled full area (untiled) map(s) and plot(s) of the mass limit
    if 'massLimitMaps' in parDict['selFnOptions'].keys():
        print(">>> Making cumulative area plots and full survey mass limit plots ...")
        for massLimitDict in parDict['selFnOptions']['massLimitMaps']:
            selFnTools.cumulativeAreaMassLimitPlot(massLimitDict['z'], diagnosticsDir) 
            selFnTools.makeFullSurveyMassLimitMapPlot(massLimitDict['z'], diagnosticsDir)
            
            
