#!/usr/bin/env python

"""

nemo driver script: for filtering maps and finding clusters

"""

import sys
#print("Running under python: %s" % (sys.version))
import os
import datetime
from nemo import *
import nemo
import argparse
import astropy.table as atpy
import numpy as np
import pylab
import pickle
import types
import yaml
import IPython
pylab.matplotlib.interactive(False)

#------------------------------------------------------------------------------------------------------------
if __name__ == '__main__':

    parser=argparse.ArgumentParser("nemo")
    parser.add_argument("configFileName", help="""A .yml configuration file.""")
    parser.add_argument("-M", "--mpi", dest="MPIEnabled", action="store_true", help="""Enable MPI. If you
                        want to use this, run using something like: mpiexec --np 4 nemo ...""", 
                        default = False)
    args = parser.parse_args()
    
    parDictFileName=args.configFileName
    parDict, rootOutDir, filteredMapsDir, diagnosticsDir, unfilteredMapsDictList, extNames, comm, rank, size=startUp.startUp(parDictFileName)
    parDict['MPIEnabled']=args.MPIEnabled

    imageDict=mapFilters.filterMaps(unfilteredMapsDictList, parDict['mapFilters'], extNames = extNames, rootOutDir = rootOutDir)
    
    # Find objects in filtered maps
    photometry.findObjects(imageDict, threshold = parDict['thresholdSigma'], minObjPix = parDict['minObjPix'], 
                           findCenterOfMass = parDict['findCenterOfMass'], rejectBorder = parDict['rejectBorder'], 
                           diagnosticsDir = diagnosticsDir, objIdent = parDict['objIdent'], longNames = parDict['longNames'],
                           useInterpolator = parDict['useInterpolator'], measureShapes = parDict['measureShapes'])
    
    # Measure fluxes
    photometry.measureFluxes(imageDict, parDict['photometryOptions'], diagnosticsDir, unfilteredMapsDict = parDict['unfilteredMaps'],
                             useInterpolator = parDict['useInterpolator'])
                    
    # Merged/optimal catalogs
    catalogTools.mergeCatalogs(imageDict)
    catalogTools.makeOptimalCatalog(imageDict, parDict['catalogCuts'])
    
    # This is useful for multi-freq, e.g., relativistic SZ corrections; tracking which objects are in 148 GHz only parts of the map
    photometry.addFreqWeightsToCatalog(imageDict, parDict['photometryOptions'], diagnosticsDir)
    
    # Estimate of contamination from running cluster finding over inverted map
    if 'estimateContaminationFromInvertedMaps' in list(parDict.keys()) and parDict['estimateContaminationFromInvertedMaps'] == True:
        contaminationTabDict=simsTools.estimateContaminationFromInvertedMaps(imageDict, extNames, parDict['thresholdSigma'], 
                                                                                parDict['minObjPix'], parDict['rejectBorder'], 
                                                                                parDict['catalogCuts'], parDict['photometryOptions'],
                                                                                diagnosticsDir, findCenterOfMass = parDict['findCenterOfMass'])
    else:
        contaminationTabDict={}
        
    # Estimate of contamination by generating a fake sky with noise, and running detection algorithm over it
    # Ultimately we want this and the above ^^^ to appear on the same plot for comparison
    if 'estimateContaminationFromSkySim' in list(parDict.keys()) and parDict['estimateContaminationFromSkySim'] == True:
        skySimContaminationTabDict=simsTools.estimateContaminationFromSkySim(imageDict, extNames, parDictFileName,
                                                                                parDict['numSkySims'],
                                                                                diagnosticsDir)
    else:
        skySimContaminationTabDict={}
    
    # This just combines inverted maps contamination results and skySim (under different keys)
    # So we only feed one dictionary into the plotting routine (see below)
    for k in list(skySimContaminationTabDict.keys()):
        contaminationTabDict[k]=skySimContaminationTabDict[k]
        
    # MPI: gather together and merge all of the catalogs from each process, and contamination test results
    if parDict['useMPI'] == True:
        optimalCatalogList=comm.gather(imageDict['optimalCatalog'], root = 0)
        contamKeysList=list(contaminationTabDict.keys())
        contaminationTabDictList=comm.gather(contaminationTabDict, root = 0)
        if rank != 0:
            assert optimalCatalogList is None
            print("... MPI rank %d finished ..." % (rank))
            sys.exit()
        else:
            print("... gathering catalogs ...")
            optimalCatalog=[]
            for cat in optimalCatalogList:
                optimalCatalog=optimalCatalog+cat
            print("... gathering and averaging contamination estimates ...")
            avContaminationTabDict={}
            for k in contamKeysList:
                tabList=[]
                avTab=None
                tabCount=0
                for tabDict in contaminationTabDictList:
                    tab=tabDict[k]
                    if type(avTab) == type(None):
                        avTab=atpy.Table()
                        for colName in list(tab.keys()):
                            avTab.add_column(atpy.Column(np.zeros(len(tab)), colName))
                    for colName in list(avTab.keys()):
                        avTab[colName]=avTab[colName]+tab[colName]
                    tabCount=tabCount+1
                for colName in list(avTab.keys()):
                    avTab[colName]=avTab[colName]/float(tabCount)
                mask=np.greater(avTab['cumSumSimCandidates'], 0)
                avTab['cumContamination']=atpy.Column(np.zeros(len(avTab)), 'cumContamination')
                avTab['cumContamination'][mask]=avTab['cumSumSimCandidates'][mask]/avTab['cumSumRealCandidates'][mask]
                avContaminationTabDict[k]=avTab
            contaminationTabDictList=avContaminationTabDict
            # And write average as .fits table(s)
            # (if we didn't run under MPI, already averaged)
            for k in list(avContaminationTabDict.keys()):
                fitsOutFileName=diagnosticsDir+os.path.sep+"%s_contaminationEstimate_%s.fits" % (k, "_average")
                if os.path.exists(fitsOutFileName) == True:
                    os.remove(fitsOutFileName)
                contaminTab=avContaminationTabDict[k]
                contaminTab.write(fitsOutFileName) 
    else:
        optimalCatalog=imageDict['optimalCatalog']
    
    # Plot contamination together
    if contaminationTabDict != {}:
        simsTools.plotContamination(contaminationTabDict, diagnosticsDir)           
    
    # Basic merged/optimal catalog
    # NOTE: now converting everything to astropy.table files here, so we can quickly remove duplicates we get under MPI
    tab=catalogTools.catalogToTab(optimalCatalog, catalogTools.COLUMN_NAMES, ["SNR > 0.0"])
    numDuplicatesFound=1e6
    while numDuplicatesFound != 0:
        tab, numDuplicatesFound, names=catalogTools.removeDuplicatesFromTab(tab)

    optimalCatalogFileName=rootOutDir+os.path.sep+"%s_optimalCatalog.csv" % (os.path.split(rootOutDir)[-1])           
    #catalogTools.writeTab(tab, optimalCatalogFileName)

    # This is a bit wasteful - we convert everything back to a catalog in doing this - but preserves current file formats
    catalogTools.writeCatalogFromTab(tab, optimalCatalogFileName, \
                                        catalogTools.COLUMN_NAMES, catalogTools.COLUMN_FORMATS, constraintsList = ["SNR > 0.0"], 
                                        headings = True)
            
    addInfo=[{'key': 'SNR', 'fmt': '%.1f'}]
    catalogTools.catalog2DS9(tab, \
                                optimalCatalogFileName.replace(".csv", ".reg"), \
                                constraintsList = ["SNR > 0.0"], \
                                addInfo = addInfo, color = "cyan") 

