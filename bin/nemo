#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# nemo driver script: for filtering maps and finding clusters

import sys
import os
import datetime
from nemo import *
import nemo
import pylab
import pickle
import IPython
pylab.matplotlib.interactive(False)

#------------------------------------------------------------------------------------------------------------
# Main
if len(sys.argv) < 2:
    print "Run: % nemo < .par file(s)>"
else:
    
    parDictFileNames=sys.argv[1:]
    
    for parDictFileName in parDictFileNames:
    
        print ">>> Running .par file: %s" % (parDictFileName)
        parDict=actDict.ACTDict()
        parDict.read_from_file(parDictFileName)

        # Output dirs
        if 'outputDir' in parDict.keys():
            rootOutDir=parDict['outDir']
        else:
            if parDictFileName.find(".par") == -1:
                raise Exception, "File must have .par extension"
            rootOutDir=sys.argv[1].replace(".par", "")
        filteredMapsDir=rootOutDir+os.path.sep+"filteredMaps"
        filtersDir=rootOutDir+os.path.sep+"filters"
        diagnosticsDir=rootOutDir+os.path.sep+"diagnostics"
        dirList=[rootOutDir, filteredMapsDir, filtersDir]
        for d in dirList:
            if os.path.exists(d) == False:
                os.makedirs(d)
        
        # tileDeck file handling - either make one, or handle loading of one
        # If we don't want to use a tileDeck file (settings not given in .par file)
        unfilteredMapsDictList, extNames=mapTools.makeTileDeck(parDict)
        
        # For when we want to test on only a subset of tiles
        if 'extNameList' in parDict.keys():
            newList=[]
            for name in extNames:
                if name in parDict['extNameList']:
                    newList.append(name)
            if newList == []:
                raise Exception, "extNameList given in .par file but no extensions in images match"
            extNames=newList
      
        # Filter maps
        imageDict=mapTools.filterMaps(unfilteredMapsDictList, parDict['mapFilters'], extNames = extNames, rootOutDir = rootOutDir)
        
        # Find objects in filtered maps
        photometry.findObjects(imageDict, threshold = parDict['thresholdSigma'], minObjPix = parDict['minObjPix'], 
                               findCenterOfMass = parDict['findCenterOfMass'], rejectBorder = parDict['rejectBorder'], 
                               diagnosticsDir = diagnosticsDir, objIdent = parDict['objIdent'], longNames = parDict['longNames'])
        
        # Measure fluxes
        photometry.measureFluxes(imageDict, parDict['photometryOptions'], diagnosticsDir, unfilteredMapsDict = parDict['unfilteredMaps'])
                    
        # Merged/optimal catalogs
        catalogTools.mergeCatalogs(imageDict)
        catalogTools.makeOptimalCatalog(imageDict, parDict['catalogCuts'])
        
        # Estimate of contamination from running cluster finding over inverted map (this takes no time really)
        # Makes a plot and we write a .fits table under diagnostics dir
        contaminationTabDict=simsTools.estimateContaminationFromInvertedMaps(imageDict, parDict['thresholdSigma'], 
                                                                          parDict['minObjPix'], parDict['rejectBorder'], 
                                                                          parDict['catalogCuts'], parDict['photometryOptions'],
                                                                          diagnosticsDir, findCenterOfMass = parDict['findCenterOfMass'])        
          
        # Estimate of contamination by generating a fake sky with noise, and running detection algorithm over it
        # Ultimately we want this and the above ^^^ to appear on the same plot for comparison
        if 'estimateContaminationFromSkySim' in parDict.keys() and parDict['estimateContaminationFromSkySim'] == True:
            skySimContaminationTabDict=simsTools.estimateContaminationFromSkySim(imageDict, parDictFileName,
                                                                                 parDict['numSkySims'],
                                                                                 diagnosticsDir)
        else:
            skySimContaminationTabDict={}
        
        # Plot contamination together
        for k in skySimContaminationTabDict.keys():
            contaminationTabDict[k]=skySimContaminationTabDict[k]
        simsTools.plotContamination(contaminationTabDict, diagnosticsDir)
        

        # Sims based on inserting fake cluster profiles into the maps
        if 'fakeSourceSimOptions' in parDict.keys():
            simsTools.fakeSourceSims(parDict['fakeSourceSimOptions'], parDict['unfilteredMaps'], parDict['mapFilters'],
                                     parDict['thresholdSigma'], parDict['minObjPix'], parDict['rejectBorder'],
                                     parDict['minSNToIncludeInOptimalCatalog'], parDict['photometryOptions'], 
                                     diagnosticsDir)
        
        # If asked for, check against inputs sim catalog
        if 'compareToSim' in parDict.keys() and parDict['compareToSim'] == True:
            simsTools.compareToInputSimCatalog(imageDict, parDict['inputSimCatalog'], 
                                            parDict['noiselessSimMap'], \
                                            parDict['photometryOptions'], \
                                            outDir = diagnosticsDir, \
                                            YLimit = parDict['minYLimit_arcmin2'], \
                                            zRange = parDict['zRange'], \
                                            convertFromJySrToMicroK = False, \
                                            obsFreqGHz = 148.0,
                                            clusterProfilesToPlot = [])
            outKeys=outKeys+['inputSim_flux_arcmin2', 'inputSim_RvirMpc', 'inputSim_Mvir']
            outFormats=outFormats+['%.3e', '%.3f', '%.3f']

        # Basic merged/optimal catalog
        optimalCatalogFileName=rootOutDir+os.path.sep+"%s_optimalCatalog.csv" % (os.path.split(rootOutDir)[-1])           
        catalogTools.writeCatalog(imageDict['optimalCatalog'], optimalCatalogFileName, \
                                  catalogTools.COLUMN_NAMES, catalogTools.COLUMN_FORMATS, constraintsList = ["SNR > 0.0"], 
                                  headings = True)
        addInfo=[{'key': 'SNR', 'fmt': '%.1f'}, {'key': 'fractionMapsDetected', 'fmt': '%.2f'}]
        catalogTools.catalog2DS9(imageDict['optimalCatalog'], \
                                 optimalCatalogFileName.replace(".csv", ".reg"), \
                                 constraintsList = ["SNR > 0.0"], \
                                 addInfo = addInfo, color = "cyan") 


    
    
