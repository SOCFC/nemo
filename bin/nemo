#!/usr/bin/env python

"""

nemo driver script: for filtering maps and finding clusters

"""

import sys
#print("Running under python: %s" % (sys.version))
import os
import datetime
from nemo import *
import nemo
import argparse
import astropy.table as atpy
import numpy as np
import pylab
import pickle
import types
import yaml
import IPython
pylab.matplotlib.interactive(False)

#------------------------------------------------------------------------------------------------------------
if __name__ == '__main__':

    parser=argparse.ArgumentParser("nemo")
    parser.add_argument("configFileName", help="""A .yml configuration file.""")
    parser.add_argument("-M", "--mpi", dest="MPIEnabled", action="store_true", help="""Enable MPI. If you
                        want to use this, run using something like: mpiexec --np 4 nemo ...""", 
                        default = False)
    args=parser.parse_args()
    
    parDictFileName=args.configFileName
    config=startUp.NemoConfig(parDictFileName, MPIEnabled = args.MPIEnabled)

    imageDict=mapFilters.filterMaps(config.unfilteredMapsDictList, config.parDict['mapFilters'], 
                                    extNames = config.extNames, rootOutDir = config.rootOutDir)
    
    # Find objects in filtered maps
    photometry.findObjects(imageDict, threshold = config.parDict['thresholdSigma'], 
                           minObjPix = config.parDict['minObjPix'], 
                           findCenterOfMass = config.parDict['findCenterOfMass'], 
                           rejectBorder = config.parDict['rejectBorder'], 
                           diagnosticsDir = config.diagnosticsDir, objIdent = config.parDict['objIdent'], 
                           longNames = config.parDict['longNames'],
                           useInterpolator = config.parDict['useInterpolator'], 
                           measureShapes = config.parDict['measureShapes'])
    
    # Measure fluxes
    photometry.measureFluxes(imageDict, config.parDict['photometryOptions'], config.diagnosticsDir, 
                             unfilteredMapsDict = config.parDict['unfilteredMaps'],
                             useInterpolator = config.parDict['useInterpolator'])
                    
    # Merged/optimal catalogs
    catalogTools.mergeCatalogs(imageDict)
    catalogTools.makeOptimalCatalog(imageDict, config.parDict['catalogCuts'])
    
    # This is useful for multi-freq, e.g., relativistic SZ corrections; tracking which objects are in 148 GHz only parts of the map
    photometry.addFreqWeightsToCatalog(imageDict, config.parDict['photometryOptions'], 
                                       config.diagnosticsDir)
    
    # Estimate of contamination from running cluster finding over inverted map
    if 'estimateContaminationFromInvertedMaps' in list(config.parDict.keys()) and config.parDict['estimateContaminationFromInvertedMaps'] == True:
        conTabDict=simsTools.estimateContaminationFromInvertedMaps(imageDict, config.extNames, 
                                                                   config.parDict['thresholdSigma'], 
                                                                   config.parDict['minObjPix'], 
                                                                   config.parDict['rejectBorder'], 
                                                                   config.parDict['catalogCuts'], 
                                                                   config.parDict['photometryOptions'],
                                                                   config.diagnosticsDir, 
                                                                   findCenterOfMass = config.parDict['findCenterOfMass'])
    else:
        conTabDict={}
        
    # Estimate of contamination by generating a fake sky with noise, and running detection algorithm over it
    # Ultimately we want this and the above ^^^ to appear on the same plot for comparison
    if 'estimateContaminationFromSkySim' in list(config.parDict.keys()) and config.parDict['estimateContaminationFromSkySim'] == True:
        skySimConTabDict=simsTools.estimateContaminationFromSkySim(imageDict, config.extNames, 
                                                                   parDictFileName,
                                                                   config.parDict['numSkySims'],
                                                                   config.diagnosticsDir)
    else:
        skySimConTabDict={}
    
    # This just combines inverted maps contamination results and skySim (under different keys)
    # So we only feed one dictionary into the plotting routine (see below)
    for k in list(skySimConTabDict.keys()):
        conTabDict[k]=skySimConTabDict[k]
        
    # MPI: gather together and merge all of the catalogs from each process, and contamination test results
    if config.parDict['useMPI'] == True:
        optimalCatalogList=comm.gather(imageDict['optimalCatalog'], root = 0)
        conKeysList=list(conTabDict.keys())
        conTabDictList=comm.gather(conTabDict, root = 0)
        if rank != 0:
            assert optimalCatalogList is None
            print("... MPI rank %d finished ..." % (rank))
            sys.exit()
        else:
            print("... gathering catalogs ...")
            optimalCatalog=[]
            for cat in optimalCatalogList:
                optimalCatalog=optimalCatalog+cat
            print("... gathering and averaging contamination estimates ...")
            avContaminationTabDict={}
            for k in conKeysList:
                tabList=[]
                avTab=None
                tabCount=0
                for tabDict in conTabDictList:
                    tab=tabDict[k]
                    if type(avTab) == type(None):
                        avTab=atpy.Table()
                        for colName in list(tab.keys()):
                            avTab.add_column(atpy.Column(np.zeros(len(tab)), colName))
                    for colName in list(avTab.keys()):
                        avTab[colName]=avTab[colName]+tab[colName]
                    tabCount=tabCount+1
                for colName in list(avTab.keys()):
                    avTab[colName]=avTab[colName]/float(tabCount)
                mask=np.greater(avTab['cumSumSimCandidates'], 0)
                avTab['cumContamination']=atpy.Column(np.zeros(len(avTab)), 'cumContamination')
                avTab['cumContamination'][mask]=avTab['cumSumSimCandidates'][mask]/avTab['cumSumRealCandidates'][mask]
                avConTabDict[k]=avTab
            conTabDictList=avConTabDict
            # And write average as .fits table(s)
            # (if we didn't run under MPI, already averaged)
            for k in list(avConTabDict.keys()):
                fitsOutFileName=config.diagnosticsDir+os.path.sep+"%s_contaminationEstimate_%s.fits" % (k, "_average")
                if os.path.exists(fitsOutFileName) == True:
                    os.remove(fitsOutFileName)
                conTab=avConTabDict[k]
                conTab.write(fitsOutFileName) 
    else:
        optimalCatalog=imageDict['optimalCatalog']
    
    # Plot contamination together
    if conTabDict != {}:
        simsTools.plotContamination(conTabDict, config.diagnosticsDir)           
    
    # Basic merged/optimal catalog
    # NOTE: now converting everything to astropy.table files here, so we can quickly remove duplicates we get under MPI
    tab=catalogTools.catalogToTab(optimalCatalog, catalogTools.COLUMN_NAMES, ["SNR > 0.0"])
    numDuplicatesFound=1e6
    while numDuplicatesFound != 0:
        tab, numDuplicatesFound, names=catalogTools.removeDuplicatesFromTab(tab)

    optimalCatalogFileName=config.rootOutDir+os.path.sep+"%s_optimalCatalog.csv" % (os.path.split(config.rootOutDir)[-1])           
    #catalogTools.writeTab(tab, optimalCatalogFileName)

    # This is a bit wasteful - we convert everything back to a catalog in doing this - but preserves current file formats
    catalogTools.writeCatalogFromTab(tab, optimalCatalogFileName, \
                                     catalogTools.COLUMN_NAMES, catalogTools.COLUMN_FORMATS, constraintsList = ["SNR > 0.0"], 
                                     headings = True)
            
    addInfo=[{'key': 'SNR', 'fmt': '%.1f'}]
    catalogTools.catalog2DS9(tab, \
                                optimalCatalogFileName.replace(".csv", ".reg"), \
                                constraintsList = ["SNR > 0.0"], \
                                addInfo = addInfo, color = "cyan") 

