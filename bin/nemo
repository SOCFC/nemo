#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# nemo driver script: for filtering maps and finding clusters

import sys
import os
import datetime
from nemo import *
import nemo
import pylab
import pickle
import IPython
pylab.matplotlib.interactive(False)

#------------------------------------------------------------------------------------------------------------
# Main
if len(sys.argv) < 2:
    print "Run: % nemo < .par file(s)>"
else:
    
    parDictFileNames=sys.argv[1:]
    
    for parDictFileName in parDictFileNames:
    
        print ">>> Running .par file: %s" % (parDictFileName)
        parDict=actDict.ACTDict()
        parDict.read_from_file(parDictFileName)

        # Output dirs
        if 'outputDir' in parDict.keys():
            rootOutDir=parDict['outDir']
        else:
            if parDictFileName.find(".par") == -1:
                raise Exception, "File must have .par extension"
            rootOutDir=sys.argv[1].replace(".par", "")
        filteredMapsDir=rootOutDir+os.path.sep+"filteredMaps"
        filtersDir=rootOutDir+os.path.sep+"filters"
        diagnosticsDir=rootOutDir+os.path.sep+"diagnostics"
        dirList=[rootOutDir, filteredMapsDir, filtersDir]
        for d in dirList:
            if os.path.exists(d) == False:
                os.makedirs(d)
                
        # Filter maps
        imageDict=mapTools.filterMaps(parDict['unfilteredMaps'], parDict['mapFilters'], rootOutDir = rootOutDir)
        
        # Find objects in filtered maps
        photometry.findObjects(imageDict, threshold = parDict['thresholdSigma'], minObjPix = parDict['minObjPix'],
                               rejectBorder = parDict['rejectBorder'], diagnosticsDir = diagnosticsDir)
        
        # Measure fluxes
        photometry.measureFluxes(imageDict, parDict['photometryOptions'], diagnosticsDir, unfilteredMapsDict = parDict['unfilteredMaps'])
        
        # Merged/optimal catalogs
        catalogTools.mergeCatalogs(imageDict)
        catalogTools.makeOptimalCatalog(imageDict, parDict['catalogCuts'])
        
        # Estimate of contamination from running cluster finding over inverted map (this takes no time really)
        # Makes a plot and we write a .fits table under diagnostics dir
        contaminationDict=simsTools.estimateContaminationFromInvertedMaps(imageDict, parDict['thresholdSigma'], 
                                                                          parDict['minObjPix'], parDict['rejectBorder'], 
                                                                          parDict['catalogCuts'],
                                                                          diagnosticsDir = diagnosticsDir)        
            
        # Sims based on inserting fake cluster profiles into the maps
        if 'fakeSourceSimOptions' in parDict.keys():
            simsTools.fakeSourceSims(parDict['fakeSourceSimOptions'], parDict['unfilteredMaps'], parDict['mapFilters'],
                                     parDict['thresholdSigma'], parDict['minObjPix'], parDict['rejectBorder'],
                                     parDict['minSNToIncludeInOptimalCatalog'], parDict['photometryOptions'], 
                                     diagnosticsDir)
                            
        # Default out catalog keys and formats for merged/optimal catalogs
        # Base keys, formats, labels used in the big table page
        baseKeys=['name', 'RADeg', 'decDeg', 'SN', 'fractionMapsDetected']
        baseFormats=["%s", "%.6f", "%.6f", "%.1f", "%.2f"]
        baseLabels=["Name", "R.A. (degrees)", "Dec. (degrees)", "S/N", "Fraction of maps object detected in", ]
        # Default extra keys etc. shown on individual source pages
        #outKeys=baseKeys+['template', 'galacticLatDeg', 'deltaT_c', 'y_c', 'flux_arcmin2', 'fluxErr_arcmin2']
        #outFormats=baseFormats+["%s", "%.3f", "%.3f", "%.3e", "%.3e", "%.3e"]
        #outLabels=baseLabels+["Signal template","Galactic Latitude (degrees)", "&Delta;T<sub>c</sub> (&mu;K)", "y<sub>c</sub>", "Y (arcmin<sup>2</sup>)", "Y error (arcmin<sup>2</sup>)"]        
        outKeys=baseKeys+['template', 'galacticLatDeg', 'deltaT_c', 'y_c', 'Y500_sr', 'err_Y500_sr']
        outFormats=baseFormats+["%s", "%.3f", "%3f", "%.3e", "%.3e", "%.3e"]
        outLabels=baseLabels+["Signal template", "Galactic Latitude (degrees)", "&Delta;T<sub>c</sub> (&mu;K)", "y<sub>c</sub>", "Y<sub>500</sub> (sr)", "&Delta;Y<sub>500</sub> (sr)"]
        if len(outKeys) != len(outFormats) and len(outFormats) != len(outLabels):
            raise Exception, "outKeys, outFormats, outLabels lists must be same length"
        addInfo=[{'key': 'SN', 'fmt': '%.1f'}, {'key': 'fractionMapsDetected', 'fmt': '%.2f'}]
        
        # If asked for, check against inputs sim catalog
        if 'compareToSim' in parDict.keys() and parDict['compareToSim'] == True:
            simsTools.compareToInputSimCatalog(imageDict, parDict['inputSimCatalog'], 
                                            parDict['noiselessSimMap'], \
                                            parDict['photometryOptions'], \
                                            outDir = diagnosticsDir, \
                                            YLimit = parDict['minYLimit_arcmin2'], \
                                            zRange = parDict['zRange'], \
                                            convertFromJySrToMicroK = False, \
                                            obsFreqGHz = 148.0,
                                            clusterProfilesToPlot = [])
            outKeys=outKeys+['inputSim_flux_arcmin2', 'inputSim_RvirMpc', 'inputSim_Mvir']
            outFormats=outFormats+['%.3e', '%.3f', '%.3f']
                        
        # Basic merged/optimal catalog
        optimalCatalogFileName=rootOutDir+os.path.sep+"%s_optimalCatalog.csv" % (os.path.split(rootOutDir)[-1])
        catalogTools.writeCatalog(imageDict['optimalCatalog'], optimalCatalogFileName, \
                                outKeys, outFormats, constraintsList = ["SN > 0.0"], 
                                headings = True)
        catalogTools.catalog2DS9(imageDict['optimalCatalog'], \
                                optimalCatalogFileName.replace(".csv", ".reg"), \
                                constraintsList = ["SN > 0.0"], \
                                addInfo = addInfo, color = "cyan") 


    
    
